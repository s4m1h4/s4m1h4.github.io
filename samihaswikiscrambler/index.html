<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>samiha's wiki scrambler</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root { --cols: 9; --rows: 5; }

  body {
    background: #fff;
    font-family: Arial, sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 20px;
  }

  #grid-wrap {
    width: 100%;
    max-width: min(92vw, 130vh);
    box-shadow: 0 20px 80px rgba(0,0,0,0.22), 0 4px 20px rgba(0,0,0,0.10);
    clip-path: polygon(
      0.8% 2.1%, 3.2% 0.3%, 7.1% 1.4%, 12.4% 0%, 18.9% 1.8%,
      25.3% 0.4%, 31.7% 2.2%, 38.1% 0.6%, 44.5% 1.9%, 51.0% 0.2%,
      57.4% 1.7%, 63.8% 0.5%, 70.2% 2.0%, 76.6% 0.3%, 83.0% 1.6%,
      89.4% 0.8%, 95.8% 1.3%, 99.2% 0.5%, 100% 3.4%, 98.7% 9.8%,
      99.5% 18.2%, 98.2% 27.6%, 99.8% 36.9%, 98.5% 46.3%, 99.3% 55.7%,
      98.0% 65.1%, 99.6% 74.4%, 98.3% 83.8%, 99.1% 93.2%, 98.8% 97.8%,
      96.1% 99.5%, 89.7% 98.2%, 83.3% 100%, 76.9% 98.6%, 70.5% 99.9%,
      64.1% 98.3%, 57.7% 100%, 51.3% 98.7%, 44.9% 99.4%, 38.5% 98.1%,
      32.1% 99.8%, 25.7% 98.5%, 19.3% 100%, 12.9% 98.8%, 6.5% 99.2%,
      1.4% 98.0%, 0% 95.1%, 1.3% 86.7%, 0.5% 77.3%, 1.8% 67.9%,
      0.2% 58.5%, 1.5% 49.1%, 0.7% 39.7%, 2.0% 30.3%, 0.4% 20.9%, 1.7% 11.5%
    );
  }

  #grid {
    display: grid;
    grid-template-columns: repeat(var(--cols), 1fr);
    aspect-ratio: var(--cols) / var(--rows);
    gap: 3px;
    overflow: hidden;
  }

  .cell { position: relative; cursor: pointer; }

  .cell img {
    position: absolute;
    inset: 0; width: 100%; height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.15s ease;
  }

  .cell .bg { z-index: 1; }

  .cell .blur {
    z-index: 2;
    filter: blur(6px);
    transform: scale(1.08);
    mask-image: radial-gradient(ellipse 60% 60% at 50% 50%, transparent 5%, black 25%);
    -webkit-mask-image: radial-gradient(ellipse 60% 60% at 50% 50%, transparent 5%, black 25%);
  }

  .cell .edge {
    position: absolute; inset: -1px; z-index: 3; pointer-events: none;
    background:
      linear-gradient(to right,  #fff 0%, transparent 20%, transparent 80%, #fff 100%),
      linear-gradient(to bottom, #fff 0%, transparent 20%, transparent 80%, #fff 100%);
  }

  #status {
    margin-top: 16px; font-size: 0.6rem;
    letter-spacing: 0.1em; color: #0a0a0a; opacity: 0.4;
  }

  #loading {
    position: fixed; inset: 0; background: #fff;
    display: flex; align-items: center; justify-content: center;
    z-index: 999; transition: opacity 0.5s ease;
  }
  #loading.done { opacity: 0; pointer-events: none; }
  #loading span {
    font-size: 0.65rem; letter-spacing: 0.2em; color: #0a0a0a; opacity: 0.4;
  }
</style>
</head>
<body>

<div id="loading"><span>loadingâ€¦</span></div>
<div id="grid-wrap"><div id="grid"></div></div>
<div id="status"></div>

<script>
const grid    = document.getElementById('grid');
const status  = document.getElementById('status');
const loading = document.getElementById('loading');
const cells = [], articles = [];
const ready = [], pending = [];
let filling = false;

const clickSrc = 'click.mp3';
function playClick() {
  const s = new Audio(clickSrc);
  s.play().catch(() => {});
}

function getDims() { return { cols: 9, rows: 5 }; }

async function fillPool(n = 50) {
  if (filling) return;
  filling = true;
  try {
    const url = `https://en.wikipedia.org/w/api.php?action=query&generator=random&grnnamespace=0&grnlimit=${Math.min(n, 50)}&prop=pageimages|info&pithumbsize=80&inprop=url&format=json&origin=*`;
    const res = await fetch(url);
    const data = await res.json();
    const pages = Object.values(data?.query?.pages || {});
    pages.forEach(p => {
      if (!p.thumbnail?.source) return;
      const entry = { image: p.thumbnail.source, url: p.fullurl || '#' };
      const img = new Image();
      img.onload  = () => { entry.cached = true; ready.push(entry); };
      img.onerror = () => {};
      img.src = entry.image;
      pending.push(entry);
    });
  } catch(e) {}
  filling = false;
}

function pop() {
  if (ready.length)   return ready.shift();
  if (pending.length) return pending.shift();
  return null;
}

async function loadCell(i) {
  const cell = cells[i];
  if (!cell || cell.dataset.loading) return;
  cell.dataset.loading = 1;
  if (ready.length + pending.length < 20) fillPool(50);
  let art = null;
  while (!art) {
    art = pop();
    if (!art) {
      if (!filling) fillPool(50);
      await new Promise(r => setTimeout(r, 30));
    }
  }
  articles[i] = art;
  const apply = () => {
    const [bg, blur] = cell.querySelectorAll('img');
    bg.src = blur.src = art.image;
    bg.style.opacity = blur.style.opacity = 1;
    cell.dataset.loading = '';
  };
  if (art.cached) { apply(); return; }
  const img = new Image();
  img.onload  = apply;
  img.onerror = () => { cell.dataset.loading = ''; loadCell(i); };
  img.src = art.image;
}

async function buildGrid() {
  const { cols, rows } = getDims(), size = cols * rows;
  document.documentElement.style.setProperty('--cols', cols);
  document.documentElement.style.setProperty('--rows', rows);
  grid.innerHTML = '';
  cells.length = articles.length = 0;
  ready.length = pending.length = 0;
  filling = false;

  for (let i = 0; i < size; i++) {
    articles.push(null);
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.innerHTML = '<img class="bg"><img class="blur"><div class="edge"></div>';
    grid.appendChild(cell);
    cells.push(cell);
    cell.addEventListener('mouseenter', () => { loadCell(i); if (ready.length < 10) fillPool(50); });
    cell.addEventListener('click', () => {
      playClick();
      if (articles[i]) window.open(articles[i].url, '_blank');
    });
    cell.addEventListener('touchstart', e => {
      e.preventDefault();
      playClick();
      if (articles[i] && cell.dataset.touched) return window.open(articles[i].url, '_blank');
      cell.dataset.touched = 1;
      setTimeout(() => cell.dataset.touched = '', 1500);
      loadCell(i);
    }, { passive: false });
  }

  fillPool(size + 20);
  await Promise.all(cells.map((_, i) => loadCell(i)));
  loading.classList.add('done');
  setTimeout(() => loading.remove(), 600);
  status.textContent = "samiha's wiki scrambler! click to visit! best on desktop browser! good luck!";
}

buildGrid();
</script>
</body>
</html>
